#pragma once

/// DataLayout 数据布局是一个结构体定义, 并且可以给每个变量定义名字和意义, 以及自定义识别ID
/// DataLayoutUnorderedBlockVector(Data) 数据分为标准数据块和非标准数据块,
///	标准数据是按照DataLayout分配的内存块, 这些内存块可以作为节点的缓存数据块, 作为参数块等
///	非标准数据内存块是按照自定义的方式分配的内存块,
///		它可以被任意的DataLayout解析(虽然可能不准确), 或者被一些特殊的修改器/查看器读取,
///		一些引擎内部的数据可能会用它表示, 或者也可能是外部的未知格式的文件数据

/// NodeContext 执行域, 它包含了执行源, 这个执行源可以是代码, 也可以是一个节点图,
///	它没有办法单独存在, 它属于节点的一个基础部件, 所有的图都是有向无环图
///	NodeContextStatic 静态执行域, 它内部可以包含 节点只读局部变量, 内部是静态结构, 具有最大优化, 域内不允许任何动态派发
///	NodeContextStaticCode 静态代码执行域,它要求代码是一个纯函数. 内部的代码和函数不能被全引擎共享, 域内不允许任何动态派发
///	NodeContextDynamic 逻辑执行域, 它内部可以包含 节点读写局部变量, 域内允许动态派发
///	NodeContextDynamicCode 动态执行域, 它要求代码是一个纯函数. 内部的代码和函数不能被全引擎共享, 域内允许动态派发
///	NodeContextProgram 程序执行域, 它内部可以包含 节点读写局部变量, 执行状态, 它可以被挂起和恢复, 域内允许动态派发, 一般它包含多个入口点和多个结束点, 需要运行顺序
///
///
///
/// CodeContextExecutor 是一个执行器, 它用于执行特定的Context,
///	 它没有办法单独存在, 它属于节点的一个基础部件
///		NodeContextExecutorContext 用于执行Context
///	 举例:
///		高级语言的执行器
///			NodeContextExecutorWarpScript 它使用引擎内部jit方案执行WarpScript
///			NodeContextExecutorCSharp 它使用.net core环境执行C#代码
///			NodeContextExecutorWASM 它用于执行WASM代码
///			NodeContextExecutorPython 它用于执行Python代码
///
///		低级表达式的执行器
///			NodeContextExecutorIR 它用于执行某个IR函数
///
///		其他:
///			NodeContextExecutorContext 它用于执行Context
///
/// Node Node是一个节点, 它按情况可以包含一个或者多个Context, 它可以决定默认运行的Context, 它本身拥有参数输入
/// 当Node允许动态派发, 那么它可以引用其他节点(预备节点), 或者通过节点名字来动态派发, 并且可以按需求调用后会主动返回, 程序动态派发允许动态派发程序和逻辑节点, 逻辑节点允许动态派发逻辑节点

/// # Node 概念
/// Node 分为: Program, Logic, Procedural.
/// ===================================================================================================
/// Procedural Node 属于数据流节点, 它是没有状态的节点, 它能最大程度并行化处理数据
/// 主要用于数据批处理, 最大程度并行化处理数据,
/// 它不能使用 数据路由节点 和 数据派发节点
/// 它拥有参数输入, 可以拥有数据输入, 必须拥有数据输出
/// 它内部可以存在多个输出节点和多个输入节点.它会计算所有的输出节点,它也可以不存在输入节点
/// 它存在固定的结束点和起始点: 它需要从输出节点向上推理到顶层, 它是一个逆序(自下而上)的求解方法,
/// 但是是一个顺序(从上往下)的数据流
/// 它可以静态使用其他的Procedural Node
/// 它以ContextStatic/ContextStaticCode作为域
///
/// ===================================================================================================
/// Logic 属于逻辑节点, 它是没有状态的节点
/// 它可以拥有参数输入, 可以拥有数据输入, 可以拥有数据输出.
/// 主要用于逻辑处理, 例如当作普通逻辑函数.
/// 它可以使用 数据路路由节点 和 数据派发节点, (但是在使用的时候需要注意:在函数内使用数据路由并不是一个高性能选择)
/// 它存在一个入口点和多个结束点, 它只能从入口点到达某一个结束点, 它是一个顺序(自上而下)的求解方法, 它拥有节点局部变量
/// 它可以静态调用与动态派发(可多线程派发)其他的Logic Node和Procedural Node
///
/// ===================================================================================================
/// Program Node 属于程序节点,
/// 它是有状态的节点, 它可以被挂起和恢复, 它可以被动态构建, 所以在创建程序节点的时候, 并没有这么轻量, 消耗回避Logic节点更高
/// 它可以动态派发其他的Program Node和Logic Node以及Procedural Node
/// 

/// reference
///
///
/// ## 容器:
/// 容器可以存储节点或数据, 或者全部存储, 它可以被动态构建, 而且非常轻量
///
/// 线性表容器, 可以存储节点, 用于动态派发
///
/// 栈树容器(用于历史记录, 用于回溯)
///
/// 节点映射表 可以存储节点, 可以用于参数->节点映射, 用于为动态派发做可选的节点准备. 每个映射点可以存储一个节点线性表
/// 

/// # 概念
/// ## NodeCoreLogicExecutor
///	举例:
///	高级语言的执行器
///		NodeContextExecutorWarpScript 它使用引擎内部jit方案执行WarpScript
///		NodeContextExecutorCSharp 它使用.net core环境执行C#代码
///		NodeContextExecutorWASM 它用于执行WASM代码
///		NodeContextExecutorPython 它用于执行Python代码
///	低级表达式的执行器
///		NodeContextExecutorIR 它用于执行某个IR函数
///
/// ## NodeCore 是存放了Node的基本信息, 它包含了执行器, 和可执行代码, 以及可执行代码的信息, 它不包含任何的状态
///
/// ## NodeLayout
///
/// ## Node 它拥有参数布局,
///
/// ProgramNode可以包含Context

/// NodeCore可以是一个数据资产, 前提是这个node被保存到了本地, 就可以一直复用它
/// NodeCore没有任何的
///

/// node cache
/// 节点具有cache, 它可以缓存节点的执行结果, 以及节点的状态, 以及节点的执行结果

/// ##Core
/// NodeContextDescriptor
/// 如果要去构建, 编辑一个Node, 那么你需要一个NodeContextDescriptor,它可以是一张图结构, 它也能包含源代码, 它可以被编辑器阅读, 它就是一个源代码
///
/// Node里面有2个东西, 一个是NodeContextDescriptor, 一个是NodeContext.
///	NodeContextDescriptor 包含了NodeContext的所有信息, 包含debug信息,以及执行方法, 用户可以通过修改它, 然后编译成NodeContext
///	NodeContext 是一个可执行结构, 它不可被阅读, 最终执行的是NodeContext, 而不是NodeContextDescriptor, 但是Viewer可以通过NodeContextDescriptor来调试NodeContext
///
///	所以, 所有的Node编译完都是静态的, 不能被动态修改, 如果要完成动态派发, 那么可以构建容器
///	可以把容器看作是一个代码生成器, 它可以快速编译成NodeContext, 也可以引用其他节点, 容器的创建速度和它的复杂度有关系, 但是相对来说它比较轻量
///	容器可以在编辑的时候创建, 也可以在运行时创建
///
/// NodeContext
/// 所有的NodeContext的拓扑图都是固定的(如果是图类型Context), 对于运行时需要创建新的运行结构, 需要使用容器.
///
///
/// 匿名Node 和 NodeAsset
///	它们的区别是, 匿名不能被引用, 而有名可以被引用, 减少重复创建
///
/// 匿名Node: 你可以随时随地创建
/// NodeAsset: 你有2种方式创建, 这两种方式在你的NodeAssetShelf上都会出现一个新节点
///	1:你可以在Node创建器里面创建.
///	2:从一个匿名Node转换成NodeAsset.
///
/// 匿名Node 支持的操作:
///	1
///
///
/// Node: 节点有4个操作, 第1个是引用, 第2个是锁定(可以选择编译), 第3个是解锁, 第4个是资产化
///	1.引用
///		你可以通过NodeAsset来实例化一个引用节点, 创建出来时,处于引用状态. 如果引用源被修改, 那么所有节点都会被修改
///	2.锁定
///		你可以锁定你的Node, 对于匿名和有名节点都可以这么操作
///		锁定之后, 你可以设置密码, 你可以选择编译, 被编译的节点无法被解锁(拓扑信息会丢失, 只保留运行结构)
///	3.解锁
///		你可以解锁你的Node, 对于匿名和有名节点都可以这么操作, 但是无法解锁被编译的节点
///	4.资产化
///		资产化可以把匿名节点编程有名节点, 它可以被引用
///
///	可以通过解锁节点来退化成一个匿名Node, 对匿名Node的修改不会影响到原来的节点, !! 被编译的节点无法被解锁(拓扑信息会丢失)
///	你可以通过重新锁定节点来进行有名化, 你可以替换原来的节点, 也可以创建一个新的节点, 只不过替换原来的节点存在风险.
///
///
/// 注意: 当你创建有名Node的时候 如果关联了其他有名Node, 你会有3个选择:
///	1. 全部退化. 2.保持引用. 3选择性退化(一般不会退化系统节点, 这个是最常用的)
///	退化和解锁不太一样, 退化不代表子节点就可以访问节点内部了, 退化只是把你的节点变成一个匿名节点, 你的节点内部的有效信息会被保存进你的Node asset里面
///	固化就是所有内部有名Node内的拓扑都会保存进你这个Node的node asset里面, 当其他有名Node发生变化的时候, 你的节点不会受到影响
///	保持引用就是所有内部的有名Node会保持引用, 当其他有名Node发生变化的时候, 你的节点也会受到影响
///

///
/// 匿名node graph可以临时创建(在创建新node的时候, node graph是空的)
/// 这样会创建一个匿名的拓扑, 你可以保存这个匿名的拓扑, 这样这个节点就会锁定
/// 
#include "NodeSystemTypes.hpp"

#include "NodeDescriptor.hpp"
#include "ContextDescriptor.hpp"

namespace Warp::NodeSystem {

	/// 
	/// {
	///	'box1' from 'box'
	///	'box2' from 'box'
	///	'box1' param 'position' is 0.5 0.5 0.5
	///
	///	'box1' opin 0 to 'box2' ipin 0
	///
	///	'hello' from graph {
	///		
	///
	///	}
	///
	///	'd' from warp_code {
	///		
	///	}
	///
	///	'box1' final
	///
	/// }

}